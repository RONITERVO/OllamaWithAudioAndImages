<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ollama Web Chat++</title>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --chat-bg: #ffffff;
            --input-bg: #ffffff;
            --user-msg-bg: #e7f5ff;
            --user-msg-text: #0056b3;
            --bot-msg-bg: #f1f3f5;
            --bot-msg-text: #212529;
            --status-text: #6c757d;
            --error-bg: #f8d7da;
            --error-text: #721c24;
            --border-color: #dee2e6;
            --control-bg: #f1f3f5;
            --button-bg: #007bff;
            --button-hover-bg: #0056b3;
            --button-disabled-bg: #ced4da;
            --link-color: #007bff;
            --vad-listening: #6c757d;
            /* gray */
            --vad-recording: #dc3545;
            /* red */
            --vad-processing: #007bff;
            /* blue */
            --vad-ready: #28a745;
            /* green */
            --vad-error: #dc3545;
            /* red */
            --vad-paused: #ffc107;
            /* yellow */
            --vad-disabled: #6c757d;
            /* gray */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: var(--bg-color);
            color: var(--bot-msg-text);
            font-size: 15px;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100%;
            max-width: 1000px;
            margin: 0 auto;
            border-left: 1px solid var(--border-color);
            border-right: 1px solid var(--border-color);
            background-color: var(--chat-bg);
        }

        #controls-area {
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--control-bg);
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            font-size: 0.9em;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-weight: 500;
            margin-bottom: 2px;
            color: #495057;
        }

        .control-group select,
        .control-group input {
            padding: 4px 6px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.95em;
        }

        .control-group button {
            padding: 4px 8px;
        }

        #chatbox-container {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
        }

        #chatbox {
            width: 100%;
            margin: 0 auto;
            flex-grow: 1;
        }

        .message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 12px;
            max-width: 85%;
            word-wrap: break-word;
            line-height: 1.5;
            position: relative;
            /* For potential future features like copy buttons */
        }

        .user {
            background-color: var(--user-msg-bg);
            color: var(--user-msg-text);
            margin-left: auto;
            border-bottom-right-radius: 2px;
        }

        .assistant {
            background-color: var(--bot-msg-bg);
            color: var(--bot-msg-text);
            margin-right: auto;
            border-bottom-left-radius: 2px;
        }

        .assistant.streaming::after {
            content: '‚ñç';
            /* Blinking cursor */
            animation: blink 1s step-end infinite;
            margin-left: 3px;
        }

        @keyframes blink {
            50% {
                opacity: 0;
            }
        }

        .error {
            background-color: var(--error-bg);
            color: var(--error-text);
            font-weight: bold;
            text-align: center;
            margin: 5px auto;
            max-width: 90%;
            border: 1px solid #f5c6cb;
        }

        .status {
            color: var(--status-text);
            text-align: center;
            font-size: 0.85em;
            margin: 5px auto;
            max-width: 90%;
        }

        .transcription {
            color: #4a00e0;
            /* Purple */
            font-style: italic;
            text-align: center;
            font-size: 0.9em;
            margin: 5px auto;
            max-width: 90%;
            padding: 5px 10px;
            background-color: #f0e6ff;
            border-radius: 8px;
        }

        #input-area {
            display: flex;
            padding: 10px 15px;
            background-color: var(--input-bg);
            border-top: 1px solid var(--border-color);
            align-items: flex-end;
            /* Align items to bottom */
        }

        textarea {
            flex-grow: 1;
            margin-right: 8px;
            padding: 8px 10px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            resize: none;
            font-family: inherit;
            font-size: 1em;
            line-height: 1.5;
            min-height: 30px;
            /* Min height for ~1 line */
            max-height: 150px;
            /* Limit expansion */
            overflow-y: auto;
            /* Add scrollbar if needed */
        }

        textarea:focus {
            outline: none;
            border-color: var(--button-bg);
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        #input-buttons {
            display: flex;
            gap: 5px;
            align-items: flex-end;
            /* Align with textarea bottom */
            margin-bottom: 3px;
            /* Align with textarea padding */
        }

        button {
            padding: 8px 12px;
            background-color: var(--button-bg);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95em;
            transition: background-color 0.2s ease;
            white-space: nowrap;
        }

        button:hover:not(:disabled) {
            background-color: var(--button-hover-bg);
        }

        button:disabled {
            background-color: var(--button-disabled-bg);
            cursor: not-allowed;
        }

        button.secondary {
            background-color: #6c757d;
        }

        button.secondary:hover:not(:disabled) {
            background-color: #5a6268;
        }


        #file-input-label {
            padding: 8px 10px;
            /* Match button padding */
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95em;
            background-color: #f8f9fa;
            transition: background-color 0.2s ease;
        }

        #file-input-label:hover {
            background-color: #e9ecef;
        }

        #file-input {
            display: none;
            /* Hide actual file input */
        }

        #attachment-info {
            font-size: 0.8em;
            margin-top: 5px;
            margin-left: 5px;
            color: var(--status-text);
            display: inline-block;
            /* Keep next to button */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
            /* Limit width */
            vertical-align: bottom;
        }

        #clear-attachment-btn {
            padding: 2px 5px;
            font-size: 0.8em;
            margin-left: 5px;
            background-color: var(--error-text);
            display: none;
            /* Hidden by default */
            vertical-align: bottom;
        }

        #vad-status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: var(--vad-disabled);
            display: inline-block;
            margin-right: 5px;
            vertical-align: middle;
            transition: background-color 0.3s ease;
        }

        #vad-status-text {
            font-size: 0.9em;
            color: var(--status-text);
            vertical-align: middle;
        }
    </style>
</head>

<body>
    <div class="container">
        <div id="controls-area">
            <div class="control-group">
                <label for="model-select">Ollama Model:</label>
                <select id="model-select" title="Select Ollama model"></select>
            </div>
            <div class="control-group">
                <label>TTS:</label>
                <div>
                    <input type="checkbox" id="tts-enable" title="Enable/Disable Text-to-Speech">
                    <select id="tts-voice-select" title="Select TTS voice"></select>
                    <input type="range" id="tts-rate-slider" min="80" max="300" step="10" title="Adjust TTS speed">
                    <span id="tts-rate-value">160</span>
                </div>
            </div>
            <div class="control-group">
                <label>Voice Input:</label>
                <div>
                    <input type="checkbox" id="vad-enable" title="Enable/Disable Voice Input (VAD/Whisper)">
                    <span id="vad-status-indicator" title="Voice input status"></span>
                    <span id="vad-status-text">Disabled</span>
                </div>
            </div>
            <div class="control-group">
                <label>Whisper:</label>
                <div>
                    <select id="whisper-lang-select" title="Select Whisper language"></select>
                    <select id="whisper-model-select" title="Select Whisper model size"></select>
                </div>
            </div>
        </div>

        <div id="chatbox-container">
            <div id="chatbox">
                <!-- Messages appear here -->
            </div>
        </div>

        <div id="input-area">
            <!-- File input button -->
            <input type="file" id="file-input"
                accept=".png,.jpg,.jpeg,.gif,.bmp,.pdf,.txt,.md,.py,.js,.html,.css,.json,.log,.csv,.xml,.yaml,.ini,.sh,.bat">
            <label for="file-input" id="file-input-label" title="Attach File">üìé</label>
            <span id="attachment-info"></span>
            <button id="clear-attachment-btn" title="Clear Attachment" class="secondary">X</button>

            <textarea id="messageInput" rows="1" placeholder="Enter your message..."></textarea>

            <div id="input-buttons">
                <button id="sendButton" title="Send Message (Enter)">Send</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const chatbox = document.getElementById('chatbox');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const fileInput = document.getElementById('file-input');
        const fileInputLabel = document.getElementById('file-input-label');
        const attachmentInfo = document.getElementById('attachment-info');
        const clearAttachmentBtn = document.getElementById('clear-attachment-btn');

        // Control Elements
        const modelSelect = document.getElementById('model-select');
        const ttsEnableCheckbox = document.getElementById('tts-enable');
        const ttsVoiceSelect = document.getElementById('tts-voice-select');
        const ttsRateSlider = document.getElementById('tts-rate-slider');
        const ttsRateValue = document.getElementById('tts-rate-value');
        const vadEnableCheckbox = document.getElementById('vad-enable');
        const vadStatusIndicator = document.getElementById('vad-status-indicator');
        const vadStatusText = document.getElementById('vad-status-text');
        const whisperLangSelect = document.getElementById('whisper-lang-select');
        const whisperModelSelect = document.getElementById('whisper-model-select');

        // --- State Variables ---
        let currentAssistantMessageDiv = null; // Holds the div for the currently streaming response
        let isStreaming = false;
        let eventSource = null; // Holds the EventSource object

        // --- Helper Functions ---
        function scrollToBottom() {
            const container = document.getElementById('chatbox-container');
            container.scrollTop = container.scrollHeight;
        }

        function escapeHtml(unsafe) {
            if (!unsafe) return "";
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function addMessage(role, text, isHtml = false) {
            console.log(`Adding message: ${role} - ${text.substring(0, 50)}...`);
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', role);

            if (isHtml) {
                messageDiv.innerHTML = text; // Use cautiously, ensure text is safe or sanitized
            } else {
                // Replace newlines with <br> for display, after escaping HTML
                messageDiv.innerHTML = escapeHtml(text).replace(/\n/g, '<br>');
            }

            chatbox.appendChild(messageDiv);
            scrollToBottom();
            return messageDiv;
        }

        function updateVadStatusUI(statusData) {
            if (!statusData || !statusData.text || !statusData.color) return;
            const colorVar = `--vad-${statusData.color.toLowerCase()}`;
            vadStatusIndicator.style.backgroundColor = `var(${colorVar}, var(--vad-disabled))`; // Fallback color
            vadStatusText.textContent = statusData.text;
            vadStatusIndicator.title = `Voice input status: ${statusData.text}`;
        }


        // --- API Interaction ---

        async function fetchApi(endpoint, options = {}) {
            try {
                const response = await fetch(endpoint, options);
                if (!response.ok) {
                    let errorMsg = `HTTP error! Status: ${response.status}`;
                    try { // Try to get more details from response body
                        const errorData = await response.json();
                        errorMsg += ` - ${errorData.message || JSON.stringify(errorData)}`;
                    } catch (e) { /* Ignore if body isn't JSON */ }
                    throw new Error(errorMsg);
                }
                // Check content type before parsing JSON
                const contentType = response.headers.get("content-type");
                if (contentType && contentType.indexOf("application/json") !== -1) {
                    return await response.json();
                } else {
                    // Handle non-JSON responses if necessary, or return null/text
                    console.log(`Non-JSON response from ${endpoint}`);
                    return await response.text(); // Or return response object itself
                }
            } catch (error) {
                console.error(`API Error (${endpoint}):`, error);
                addMessage('error', `Network or API error: ${error.message}`);
                throw error; // Re-throw for calling function to handle if needed
            }
        }

        async function fetchInitialData() {
            console.log("Fetching initial data...");
            try {
                // Fetch status first to populate controls
                const status = await fetchApi('/api/status');
                console.log("Initial Status:", status);
                updateFullUIState(status);

                // Fetch models and voices in parallel (if status didn't provide them)
                const [modelsData, voicesData] = await Promise.all([
                    fetchApi('/api/models'),
                    fetchApi('/api/voices')
                ]);

                populateDropdown(modelSelect, modelsData.models || [], status.ollama_model);
                populateDropdown(ttsVoiceSelect, (voicesData.voices || []).map(v => ({ value: v.id, text: v.name })), status.tts_voice_id);
                populateDropdown(whisperLangSelect, Object.entries(LANGUAGES).map(([name, code]) => ({ value: code ?? 'null', text: name })), status.whisper_language ?? 'null');
                populateDropdown(whisperModelSelect, WHISPER_MODELS, status.whisper_model);


                // Fetch history last
                const historyData = await fetchApi('/api/history');
                chatbox.innerHTML = ''; // Clear loading/old messages
                if (historyData.history && historyData.history.length > 0) {
                    historyData.history.forEach(msg => {
                        addMessage(msg.role, msg.content || '');
                    });
                } else {
                    addMessage('status', 'Welcome! Start by typing a message.');
                }
                addMessage('status', `Backend ready. Ollama: ${status.ollama_model || 'N/A'}.`);

            } catch (error) {
                addMessage('error', `Failed to load initial data. Please check backend and refresh. ${error.message}`);
            }
        }

        // --- Send Message Logic ---
        async function sendMessageToServer() {
            const messageText = messageInput.value.trim();
            const attachedFile = fileInput.files[0];

            if (!messageText && !attachedFile) {
                addMessage('error', 'Please enter a message or attach a file.');
                return;
            }

            // Disable inputs
            messageInput.disabled = true;
            sendButton.disabled = true;
            fileInputLabel.style.opacity = '0.6';
            clearAttachmentBtn.style.display = 'none'; // Hide clear while sending

            // Add user message visually (handle file indication)
            let displayMessage = messageText;
            if (attachedFile) {
                displayMessage += `\n[Attached: ${escapeHtml(attachedFile.name)}]`;
            }
            addMessage('user', displayMessage);


            // Use FormData for text and file
            const formData = new FormData();
            formData.append('message', messageText);
            if (attachedFile) {
                formData.append('file', attachedFile);
            }

            // Clear inputs now
            messageInput.value = '';
            fileInput.value = null; // Clear file input
            attachmentInfo.textContent = '';
            updateTextareaHeight();


            // --- Make API call ---
            try {
                const response = await fetchApi('/api/send_message', {
                    method: 'POST',
                    body: formData // Send FormData
                });
                console.log("Send response:", response);
                // SSE stream will handle Ollama response display
                // Input re-enabling is handled by stream_end or error events
            } catch (error) {
                // Error already logged by fetchApi
                // Re-enable inputs on send failure ONLY
                messageInput.disabled = false;
                sendButton.disabled = false;
                fileInputLabel.style.opacity = '1';
                // Don't re-show clear button as file wasn't sent
            }
        }

        // --- SSE Handling ---
        function setupSSE() {
            console.log("Setting up SSE connection...");
            if (eventSource) {
                eventSource.close();
            }

            eventSource = new EventSource('/api/stream');

            eventSource.onopen = function () {
                console.log("SSE Connection opened.");
                addMessage('status', 'Connected to server.');
                // Potentially re-enable inputs if they were disabled by error
                messageInput.disabled = false;
                sendButton.disabled = false;
                fileInputLabel.style.opacity = '1';
            };

            eventSource.onerror = function (event) {
                console.error("SSE Error:", event);
                // Stop streaming state
                if (currentAssistantMessageDiv) {
                    currentAssistantMessageDiv.classList.remove('streaming');
                    currentAssistantMessageDiv = null;
                    isStreaming = false;
                }
                // Indicate disconnection, disable inputs
                addMessage('error', 'Connection lost. Attempting to reconnect...');
                messageInput.disabled = true;
                sendButton.disabled = true;
                fileInputLabel.style.opacity = '0.6';
                clearAttachmentBtn.style.display = 'none';

                // Simple retry mechanism (browser usually handles this, but for explicit control)
                // setTimeout(setupSSE, 5000); // Reconnect after 5s
            };

            // --- Specific Event Listeners ---
            eventSource.addEventListener('stream_start', (event) => {
                console.log("SSE: stream_start");
                if (currentAssistantMessageDiv) { // Finalize previous if any overlap
                    currentAssistantMessageDiv.classList.remove('streaming');
                }
                // Create a new div for the assistant message
                currentAssistantMessageDiv = addMessage('assistant', ''); // Start empty
                currentAssistantMessageDiv.classList.add('streaming');
                isStreaming = true;
                scrollToBottom();
            });

            eventSource.addEventListener('stream_chunk', (event) => {
                // console.log("SSE: stream_chunk", event.data); // Noisy
                if (!currentAssistantMessageDiv) { // Shouldn't happen if start works
                    currentAssistantMessageDiv = addMessage('assistant', '');
                    currentAssistantMessageDiv.classList.add('streaming');
                }
                if (isStreaming) {
                    // Append chunk safely (handle potential HTML in chunks if needed, but default to text)
                    const chunk = JSON.parse(event.data);
                    currentAssistantMessageDiv.innerHTML += escapeHtml(chunk).replace(/\n/g, '<br>');
                    scrollToBottom();
                }
            });

            eventSource.addEventListener('stream_end', (event) => {
                console.log("SSE: stream_end");
                if (currentAssistantMessageDiv) {
                    currentAssistantMessageDiv.classList.remove('streaming');
                }
                currentAssistantMessageDiv = null;
                isStreaming = false;
                // Re-enable inputs
                messageInput.disabled = false;
                sendButton.disabled = false;
                fileInputLabel.style.opacity = '1';
                // Don't re-show clear button here, file was consumed
                messageInput.focus();
            });

            eventSource.addEventListener('error', (event) => {
                const errorData = JSON.parse(event.data);
                console.error("SSE: Backend Error:", errorData);
                addMessage('error', errorData || 'Unknown backend error occurred.');
                // Finalize streaming state on error
                if (currentAssistantMessageDiv) {
                    currentAssistantMessageDiv.classList.remove('streaming');
                    currentAssistantMessageDiv = null;
                    isStreaming = false;
                }
                // Re-enable inputs on backend error during stream
                messageInput.disabled = false;
                sendButton.disabled = false;
                fileInputLabel.style.opacity = '1';
            });

            eventSource.addEventListener('status', (event) => {
                const statusMsg = JSON.parse(event.data);
                console.log("SSE: Status:", statusMsg);
                addMessage('status', statusMsg);
            });

            eventSource.addEventListener('status_update', (event) => {
                const statusUpdate = JSON.parse(event.data);
                console.log("SSE: Status Update:", statusUpdate);
                if (statusUpdate.source === 'vad') {
                    updateVadStatusUI(statusUpdate.data);
                }
                // Handle other status sources if needed
            });

            eventSource.addEventListener('history_update', (event) => {
                const historyData = JSON.parse(event.data);
                console.log("SSE: History Update Received");
                // Diffing is complex, easiest is to redraw (can cause flicker)
                // Or just append if certain it's only new messages? Risky.
                // Let's redraw for simplicity now.
                chatbox.innerHTML = ''; // Clear
                if (historyData && historyData.length > 0) {
                    historyData.forEach(msg => {
                        addMessage(msg.role, msg.content || '');
                    });
                }
                // If streaming was interrupted by history update, reset state
                if (isStreaming) {
                    console.warn("History update interrupted streaming state.");
                    isStreaming = false;
                    currentAssistantMessageDiv = null;
                }
            });

            eventSource.addEventListener('voices_update', (event) => {
                const voices = JSON.parse(event.data);
                console.log("SSE: Voices Update:", voices);
                // Get current selected value before repopulating
                const currentVoiceId = ttsVoiceSelect.value;
                populateDropdown(ttsVoiceSelect, (voices || []).map(v => ({ value: v.id, text: v.name })), currentVoiceId);
            });

            eventSource.addEventListener('transcription', (event) => {
                const transData = JSON.parse(event.data);
                console.log("SSE: Transcription:", transData);
                addMessage('transcription', `üé§ Detected (${transData.language || 'auto'}): ${transData.text || ''}`);
                // Optionally auto-send? No, keep it simple.
            });

            eventSource.addEventListener('full_status', (event) => {
                const status = JSON.parse(event.data);
                console.log("SSE: Received Full Status on Connect:", status);
                updateFullUIState(status);
                // Update controls that weren't updated during initial fetch maybe
                // (Redundant if initial fetch worked, but safe fallback)
            });
        }

        // --- Control/Settings Logic ---

        function populateDropdown(selectElement, items, selectedValue) {
            selectElement.innerHTML = ''; // Clear existing options
            if (!items || items.length === 0) {
                selectElement.disabled = true;
                selectElement.innerHTML = '<option value="">N/A</option>';
                return;
            }

            selectElement.disabled = false;
            items.forEach(item => {
                const option = document.createElement('option');
                if (typeof item === 'string') {
                    option.value = item;
                    option.textContent = item;
                } else { // Assume {value: v, text: t} format
                    option.value = item.value;
                    option.textContent = item.text;
                }
                selectElement.appendChild(option);
            });

            // Try setting the selected value
            if (selectedValue !== undefined && selectedValue !== null) {
                selectElement.value = selectedValue;
                // If the value didn't exist, it might reset to the first option. Check this.
                if (selectElement.value !== String(selectedValue)) {
                    console.warn(`Value "${selectedValue}" not found in dropdown ${selectElement.id}, defaulting to first option.`);
                    if (items.length > 0) {
                        selectElement.selectedIndex = 0; // Select first item as fallback
                    }
                }
            } else if (items.length > 0) {
                selectElement.selectedIndex = 0; // Select first if no specific value given
            }
        }

        function updateFullUIState(status) {
            // Update controls based on the full status object
            modelSelect.value = status.ollama_model || '';
            ttsEnableCheckbox.checked = status.tts_enabled || false;
            ttsVoiceSelect.value = status.tts_voice_id || '';
            ttsRateSlider.value = status.tts_rate || 160;
            ttsRateValue.textContent = status.tts_rate || 160;
            vadEnableCheckbox.checked = status.vad_enabled || false;
            updateVadStatusUI(status.vad_status);
            whisperLangSelect.value = status.whisper_language ?? 'null'; // Handle null for auto
            whisperModelSelect.value = status.whisper_model || '';

            // Update attachment display
            if (status.attachment && status.attachment.filename) {
                attachmentInfo.textContent = ` ${status.attachment.filename}`;
                clearAttachmentBtn.style.display = 'inline-block';
            } else {
                attachmentInfo.textContent = '';
                clearAttachmentBtn.style.display = 'none';
            }

            // Enable/disable voice/rate controls based on TTS status
            ttsVoiceSelect.disabled = !status.tts_enabled;
            ttsRateSlider.disabled = !status.tts_enabled;
            // Enable/disable whisper controls based on VAD status
            whisperLangSelect.disabled = !status.vad_enabled;
            whisperModelSelect.disabled = !status.vad_enabled;
        }


        // Add event listeners for controls
        modelSelect.addEventListener('change', async () => {
            await fetchApi('/api/control/model', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ model: modelSelect.value })
            });
            // Status update ideally comes via SSE, but could force refresh: fetchApi('/api/status').then(updateFullUIState);
        });

        ttsEnableCheckbox.addEventListener('change', async () => {
            const enabled = ttsEnableCheckbox.checked;
            try {
                const data = await fetchApi('/api/control/tts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enable: enabled })
                });
                // Update dependent controls immediately based on response
                ttsVoiceSelect.disabled = !data.tts_enabled;
                ttsRateSlider.disabled = !data.tts_enabled;
            } catch (e) {
                ttsEnableCheckbox.checked = !enabled; // Revert on error
            }

        });

        ttsVoiceSelect.addEventListener('change', async () => {
            await fetchApi('/api/control/tts_settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ voice_id: ttsVoiceSelect.value })
            });
        });

        ttsRateSlider.addEventListener('input', () => { // Update value display live
            ttsRateValue.textContent = ttsRateSlider.value;
        });
        ttsRateSlider.addEventListener('change', async () => { // Send API call on release
            await fetchApi('/api/control/tts_settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ rate: parseInt(ttsRateSlider.value) })
            });
        });


        vadEnableCheckbox.addEventListener('change', async () => {
            const enabled = vadEnableCheckbox.checked;
            vadEnableCheckbox.disabled = true; // Disable during state change
            try {
                const data = await fetchApi('/api/control/vad', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enable: enabled })
                });
                // Update dependent controls immediately based on response
                whisperLangSelect.disabled = !data.vad_enabled;
                whisperModelSelect.disabled = !data.vad_enabled;
                // Update VAD status indicator based on response too
                updateVadStatusUI(data.current_status);
            } catch (e) {
                vadEnableCheckbox.checked = !enabled; // Revert on error
            } finally {
                vadEnableCheckbox.disabled = false; // Re-enable checkbox
            }

        });

        whisperLangSelect.addEventListener('change', async () => {
            const selectedLang = whisperLangSelect.value === 'null' ? null : whisperLangSelect.value;
            await fetchApi('/api/control/whisper_settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ language_code: selectedLang })
            });
        });

        whisperModelSelect.addEventListener('change', async () => {
            await fetchApi('/api/control/whisper_settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ model_size: whisperModelSelect.value })
            });
        });


        // --- Other Event Listeners ---
        sendButton.addEventListener('click', sendMessageToServer);

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessageToServer();
            }
        });

        // Auto-resize textarea
        function updateTextareaHeight() {
            messageInput.style.height = 'auto'; // Temporarily shrink
            // Set height based on scroll height, but capped by max-height
            const newHeight = Math.min(messageInput.scrollHeight, 150); // 150px is max-height from CSS
            messageInput.style.height = `${newHeight}px`;
        }
        messageInput.addEventListener('input', updateTextareaHeight);


        // File input handling
        fileInput.addEventListener('change', () => {
            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                attachmentInfo.textContent = ` ${file.name}`;
                clearAttachmentBtn.style.display = 'inline-block';
            } else {
                attachmentInfo.textContent = '';
                clearAttachmentBtn.style.display = 'none';
            }
        });

        clearAttachmentBtn.addEventListener('click', async () => {
            fileInput.value = null; // Clear the actual input
            attachmentInfo.textContent = '';
            clearAttachmentBtn.style.display = 'none';
            // Optionally notify backend the attachment was cleared *before* sending next message
            try {
                await fetchApi('/api/clear_attachment', { method: 'POST' });
            } catch (e) { /* Ignore error here, clearing is best-effort */ }
        });

        // --- Constants for dropdowns ---
        const LANGUAGES = {
            "Auto Detect": null, "English": "en", "Finnish": "fi", "Swedish": "sv",
            "German": "de", "French": "fr", "Spanish": "es", "Italian": "it",
            "Russian": "ru", "Chinese": "zh", "Japanese": "ja"
        };
        const WHISPER_MODELS = ["tiny", "base", "small", "medium", "large", "turbo-tiny", "turbo-base", "turbo-small", "turbo-medium", "turbo-large"];


        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            fetchInitialData(); // Load history, models, voices, status
            setupSSE();         // Connect to the stream
            updateTextareaHeight(); // Initial textarea height
        });

    </script>
</body>

</html>